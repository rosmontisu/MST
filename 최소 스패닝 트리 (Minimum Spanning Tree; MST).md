## 최소 스패닝 트리 분석
### 1. 알고리즘 이해
1. 최소 스패닝 트리의 정의 및 특성
	- 스패닝 트리 : 그래프내의 모든 정점을 포함하는 트리
	- 최소 스패닝 트리 : 모든 정점들을 가장 적은 수의 간선과 비용으로 연결하는 트리
	---
2. 크루스칼 및 프림 알고리즘의 작동 원리
	> 크루스칼(Kruskal) 알고리즘

	- MST는 항상 최소 비용 간선으로 구성되며, 사이클을 포함하지 않는다는 조건에 근거하여 매 루프에서 사이클을 이루지 않는 최소 비용 간선을 선택함으로 MST를 구할 수 있다.
	- 탐욕 알고리즘(Greedy)을 이용해 작동
	- 그래프의 간선들을 가중치의 오름차순으로 정렬 후 리스트에서 사이클을 형성하지 않는 간선을 찾아서 현재의 최소 스패닝 트리의 집합에 추가
	- 만약 사이클이 형성되면 해당 간선은 제거한다.
   ---
	> 프림(Prim) 알고리즘
	- 시작 정점에서부터 스패닝 트리 집합을 단계적으로 확장해나가는 방법
	- 시작 정점을 최소 스패닝 트리 집합에 추가
	- 앞 단계에서 만들어진 스패닝 트리 집합에 인접한 정점들 중에서 최저 간선으로 연결된 정점을 선택하여 트리를 확장
	- 위 과정을 트리가 n-1개의 간선을 가질 때까지 반복한다.
	---

3. 시간 복잡도 분석
- 각 알고리즘의 시간복잡도를 빅O표기법으로 나타내면 아래의 표와 같다.
- 이때, 프림 알고리즘은 그래프 구현시에 인접 행렬 방식이 아닌 인접 리스트 방식을 이용해 우선순위 큐를 활용하면 시간복잡도를 줄일 수 있다.

|           |  시간 복잡도  |           유리한 상황           |
| :-------: | :------: | :------------------------: |
|   크루스칼    | O(ElogE) | 노드(Vertex)가 많은 희소 그래프에서 유리 |
| 프림(인접행렬)  |  O(V^2)  |             -              |
| 프림(인접리스트) | O(ElogV) |  간선(Edge)이 많은 밀집 그래프에서 유리  |

---

### 2. 알고리즘 비교
1. 크루스칼 알고리즘과 프림 알고리즘의 차이점

|        |    크루스칼    |    프림    |
| :----: | :--------: | :------: |
|  접근방식  |  간선 선택 기반  | 정점 선택 기반 |
|  자료구조  | Union-Find |  우선순위 큐  |
| 그래프 유형 |   희소 그래프   |  밀집 그래프  |

---

2. 각 알고리즘의 장단점 - 네트워크 관점

|      |                              장점                               |                  단점                   |
| :--: | :-----------------------------------------------------------: | :-----------------------------------: |
| 크루스칼 | - 간선 중심으로 동작해 분산 네트워크 환경에 적합<br>- 간선 추가/제거 시 재정렬만으로 유연한 관리 가능 |      - 초기 비용이 큼 (간선 정렬을 위해)<br>       |
|  프림  |        - 특정 노드(서버 등..)를 시작점으로 한 중앙 집중식 네트워크 구성에 적합<br>        | - 노드 추가에 부담이 있음 (동적인 네트워크 변화에 취약)<br> |

3. 최소 스패닝 트리 알고리즘의 활용 - 네트워크 관점
	- 백본 네트워크 (코어 네트워크) 설계시에 핵심 알고리즘으로 사용한다.
	`백본 네트워크`
	- 정의
		- 여러 소형 네트워크를 묶어 대규모 파이프라인을 통해 극도로 높은 대역폭으로 다른 네트워크들의 집합과 연결되는 네트워크, 백본망 또는 기간망이라고 한다.
		
	- 한국에 KT, SKT, LG U+와 같은 ISP들이 설치한 기지국도 백본 네트워크인가?
		- 기지국은 엑세스 네트워크의 일부로 작동
		- 백본 네트워크는 KT의 KOREN(Korea Advanced Research Network) 과 같이 다른 개념으로 존재한다 
		- 이를 헷갈리지 않도록 간단한 관계도로 나타내면 아래와 같다.
```
[사용자(휴대폰 등)] ↔ (무선 신호) ↔ [기지국(Access)] ↔ [메트로 네트워크(Metro)] ↔ [백본 네트워크(Core)] ↔ [데이터 센터/IX/글로벌 인터넷]
```

---
### 3. 알고리즘 슈도코드 및 플로우차트 작성
- 크루스칼 알고리즘와 프림 알고리즘의 슈도코드 및 플로우차트
- 각 알고리즘의 플로우차트는 아래 사진과 같다.
	- (좌 : 크루스칼, 우 : 프림)
 ![[MST.drawio.png]]
---
- 위 순서도를 기반으로 작성한 크루스칼 슈도코드
	- 단, Union-Find 알고리즘과 Sort알고리즘 등은 생략합니다.
```py
Kruskal(G):
    MST = []                      # 최소 신장 트리 초기화
    edges = 모든 간선을 가중치 오름차순으로 정렬  # 1. 간선 정렬
    union_find = Union-Find 초기화  # 정점 그룹 관리

    while edges가 비어 있지 않을 때:  
        (u, v, weight) = edges에서 가장 낮은 비용의 간선 추출 및 제거  # 2. 간선 선택  
        
        if Find(u) != Find(v):    # 3. u와 v가 다른 그룹인지 확인  
            Union(u, v)           # 4. 같은 그룹으로 병합  
            MST.append((u, v))    # 4. MST에 간선 추가  
            
            if len(MST) == V-1:   # 5. 종료 조건 검사  
                break            # V-1개 도달 시 종료  

    return MST
```
- 위 순서도를 기반으로 작성한 프림 슈도코드
```py
Prim(G, start_vertex s):
    MST = []                      # 최소 신장 트리 초기화  
    visited = {s}                 # 1. 시작 정점을 MST에 추가  
    edges = s와 연결된 간선을 우선순위 큐에 추가 (가중치 기준)  

    while len(visited) < V:       # 모든 정점이 포함될 때까지  
        (u, v, weight) = edges에서 가장 낮은 비용의 간선 추출  # 2. 최소 비용 간선 선택  
        
        if v not in visited:      # 2. v가 MST에 포함되지 않았다면  
            MST.append((u, v))    # 3. MST에 간선 추가  
            visited.add(v)        # 3. v를 MST에 포함  
            # v와 연결된 새로운 간선을 큐에 추가  
            for (v, w, new_weight) in v의 인접 간선:  
                if w not in visited:  
                    edges에 (v, w, new_weight) 추가  

    return MST
```

---
## 알고리즘 적용 및 분석
### 1. 알고리즘 적용
- 아래와 같은 그래프가 있을때...
```
정점 = {A, B, C, D, E, F, G}
간선 = {  
(A, B, 7), (A, D, 5),  (B, C, 8), 
(B, D, 9), (B, E, 7),  (C, E, 5),  
(D, E, 15), (D, F, 6),  (E, F, 8), 
(E, G, 9),  (F, G, 11)}
(형식: (출발점, 도착점, 가중치))
```
![[Pasted image 20250324171808.png]]

---


- 각 단계별 진행 과정
1. 가중치 오름 차순 정렬
```
1. (A, D, 5)   
2. (C, E, 5)   
3. (D, F, 6)   
4. (A, B, 7) 
5. (B, E, 7) 
6. (B, C, 8)   
7. (E, F, 8)  
8. (B, D, 9)   
9. (E, G, 9)   
10. (D, E, 15)   
```
2. 간선 선택 및 사이클 검사
	- 연결
	- 현재 집합 상태
	- 연결된 간선의 가중치
	- 총 가중치
```
- A와 D 연결 (서로 다른 집합)
{A, D}, {B}, {C}, {E}, {F}, {G} 
A-D(5)   
5
    
- C와 E 연결 (서로 다른 집합) 
{A, D}, {B}, {C, E}, {F}, {G}   
C-E(5)  
5 + 5 = 10
    
- D와 F 연결 (D는 {A, D}, F는 독립) 
{A, D, F}, {B}, {C, E}, {G}  
D-F(6)   
10 + 6 = 16   

- A와 B 연결 (A는 {A, D, F}, B는 독립)  
{A, B, D, F}, {C, E}, {G}  
A-B(7)  
16 + 7 = 23   

- B와 E 연결 (B는 {A, B, D, F}, E는 {C, E})
{A, B, D, F, C, E}, {G}   
B-E(7)   
23 + 7 = 30

- E와 G 연결 (E는 {A, B, D, F, C, E}, G는 독립)
{A, B, D, F, C, E, G}  
E-G(9)  
30 + 9 = 39  
```
3. 종료 조건 확인
```
- 선택된 간선 수: 6개 (정점 7개 → MST 간선 수 = 6).   
- 모든 정점이 하나의 집합으로 통합되었으므로 종료
```
- 크루스칼을 적용해서 구한 MST
```
1. (A, D, 5)   
2. (C, E, 5)   
3. (D, F, 6)  
4. (A, B, 7)   
5. (B, E, 7)   
6. (E, G, 9)   
총 가중치 : 39
```
![[Pasted image 20250327185024.png]]

---

- 프림을 적용해서 구한 MST
1.  시작 정점이 A일때

| 단계  |  선택된 간선   | 추가된 정점 |      현재 트리 정점       |                    후보 간선들 (우선순위 큐)                     |
| :-: | :-------: | :----: | :-----------------: | :----------------------------------------------------: |
|  1  | (A, D, 5) |   D    |        A, D         |      (A, B, 7), (D, B, 9), (D, E, 15), (D, F, 6)       |
|  2  | (D, F, 6) |   F    |       A, D, F       |      (A, B, 7), (D, B, 9), (D, E, 15), (F, E, 8)       |
|  3  | (A, B, 7) |   B    |     A, D, F, B      | (B, C, 8), (B, E, 7), (D, B, 9), (D, E, 15), (F, E, 8) |
|  4  | (B, E, 7) |   E    |    A, D, F, B, E    | (B, C, 8), (E, C, 5), (E, G, 9), (D, E, 15), (F, E, 8) |
|  5  | (E, C, 5) |   C    |  A, D, F, B, E, C   |            (B, C, 8), (E, G, 9), (F, E, 8)             |
|  6  | (E, G, 9) |   G    | A, D, F, B, E, C, G |                      모든 정점 추가 완료                       |
|     |           |        |                     |                       총 가중치 : 39                       |

![[Pasted image 20250327184733.png]]

---

2. 시작 정점이 D일때

| 단계  |  선택된 간선   | 추가된 정점 |      현재 트리 정점       |                    후보 간선들 (우선순위 큐)                     |
| :-: | :-------: | :----: | :-----------------: | :----------------------------------------------------: |
|  1  | (D, A, 5) |   A    |        D, A         |      (D, B, 9), (D, E, 15), (D, F, 6), (A, B, 7)       |
|  2  | (D, F, 6) |   F    |       D, A, F       |      (D, B, 9), (D, E, 15), (A, B, 7), (F, E, 8)       |
|  3  | (A, B, 7) |   B    |     D, A, F, B      | (D, B, 9), (D, E, 15), (B, C, 8), (B, E, 7), (F, E, 8) |
|  4  | (B, E, 7) |   E    |    D, A, F, B, E    | (D, E, 15), (B, C, 8), (E, C, 5), (E, G, 9), (F, E, 8) |
|  5  | (E, C, 5) |   C    |  D, A, F, B, E, C   |            (B, C, 8), (E, G, 9), (F, E, 8)             |
|  6  | (E, G, 9) |   G    | D, A, F, B, E, C, G |                      모든 정점 추가 완료                       |
|     |           |        |                     |                       총 가중치 : 39                       |

![[Pasted image 20250327184855.png]]

---

### 2. 네트워크 분석
- 네트워크 장애 발생시 (D-F 링크 끊어짐) MST의 변화를 설명하기
- 아래 사진처럼 장애가 발생하면?
 ![[Pasted image 20250327185309.png]]
- F노드가 MST 그룹에서 이탈된다.
- 사이클이 발생하지 않는 가장 가중치가 낮은 간선인 F-E 로 새 링크를 연결해준다.
 ![[Pasted image 20250327185632.png]]
- 결과적으로 MST의 총 가중치는 41이 되고 그래프는 위 그림과 같이 변경된다.
